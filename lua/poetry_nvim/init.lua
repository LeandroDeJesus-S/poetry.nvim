---@class poetry.PluginOpt
---@field enabled boolean: whether enable the plugin
---@field opts? table: plugin options

---@class poetry.Options
---@field plugins table<string, poetry.PluginOpt>: poetry plugins configuration
---@field lsp? string: the name of the lsp client
---@field fallback_envs? string[]: python environments to try to find if poetry env is not found
---@field keymaps? table: keymaps to add to the poetry shell plugin

local M = {}
local state = {
	wk_gp = "Poetry",
	default_lsp = "pyright",
	fallback_envs = { -- generated by AI
		".venv",
		"venv",
		".env",
		"env",

		".poetry_venv",
		".virtualenv",
		"virtualenv",
		".pipenv",
		"pipenv",
		".direnv",
		"direnv",

		"venv3",
		"venv2",
		"pyenv",
		".pyenv",
		"py-venv",
		"python-env",
		"python_env",
		"py_env",
		"pyenv-virtualenv",

		".venv-dev",
		".venv-prod",
		".venv-test",
		".venv-local",
		".venv-build",
		".venv-ci",
		".venv-env",
		".env-dev",
		".env-prod",
		".env-test",
		".env-local",

		".venv-api",
		".venv-worker",
		".venv-auth",
		".venv-backend",
		".venv-frontend",
		".venv-server",
		".venv-client",
		".venv-app",

		".snake",
		"snake",
		".cobra",
		"cobra",
		".kobra",
		"kobra",
		".sandbox",
		"sandbox",
		".lab",
		"lab",
		".envs",
		"envs",

		"venv_env",
		"virtual_env",
		"virtual-env",
		"python-venv",
		"pythonvenv",

		"venv_env",
		"venv_local",
		"env_local",
		".venv_local",
		".env_local",

		"ENV",
		"VENV",
		".VENV",
		".ENV",
	},
	keymaps = {},
}

--- Sets up keymaps for the Poetry LSP plugin.
--- This function registers a base keymap group and extends it with additional keymaps
--- provided by the plugin or user, specifically for managing the Poetry LSP environment.
---
--- @param lsp poetry.LSP The active LSP object from the `poetry` plugin, used to call its methods (e.g., `lsp.reset`).
--- @param keymaps table A list of `which-key` compatible keymap definitions to be added alongside the base Poetry LSP keymaps.
local function overall_keymaps(lsp, keymaps)
	local wk = require("which-key")

	wk.add({
		{ "<leader>p", group = state.wk_gp },
		vim.list_extend({
			{
				mode = "n",
				"<leader>pd",
				lsp.reset,
				desc = "Disable Poetry LSP Environment setup",
			},
		}, keymaps),
	})
end

--- Sets up the Neovim poetry integration, initializing LSP and configured plugins.
--- This function merges user-provided options with default values, dynamically loads
--- the specified LSP configuration, and then iterates through and sets up
--- each enabled poetry plugin.
--- @param opts poetry.Options Configuration options for the poetry integration.
---   containing `enabled` (boolean) and `opts` (table) for the respective plugin. Defaults to `{}`.
---   Defaults to `state.default_lsp`.
---   These are extended with `state.fallback_envs`.
M.setup = function(opts)
	local o = opts or {}
	o.plugins = o.plugins or {}
	o.lsp = o.lsp or state.default_lsp
	-- Extend fallback environments, prepending user-defined ones to global fallbacks.
	o.fallback_envs = vim.list_extend(o.fallback_envs or {}, state.fallback_envs)

	---@type poetry.LSP
	local lsp = require(string.format("lsps.%s", o.lsp))
	-- If 'require' returns 'true', it indicates the module was not found or failed to load correctly.
	if lsp == true then
		vim.notify("LSP not found or not supported", vim.log.levels.ERROR, {})
		return
	end

	for plugin_name, plugin_opts in pairs(o.plugins) do
		if not plugin_opts.enabled then
			goto continue
		end

		-- TODO: add a way to user define custom plugin setup from his own config

		---@type poetry.Plugin
		local plugin = require(string.format("poetry_plugins.%s", plugin_name))
		if plugin == true then
			vim.notify(string.format("Plugin %s not found", plugin_name), vim.log.levels.ERROR, {})
			return
		end

		plugin.setup(plugin_opts.opts or {})

		::continue::
	end

	overall_keymaps(lsp, opts.keymaps or {})
	lsp.configure({ fallback_envs = o.fallback_envs })
end

return M
